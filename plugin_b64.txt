##############################################
# YoureWatching Plugin for Enigma2
# Compatible with Python 3.13
# Shows "You're watching..." overlay with
# movie poster and title on channel change
##############################################

from Plugins.Plugin import PluginDescriptor
from Screens.Screen import Screen
from Components.Label import Label
from Components.Pixmap import Pixmap
from Components.ActionMap import ActionMap
from Components.ConfigList import ConfigList, ConfigListScreen
from Components.config import (
    config, ConfigSubsection, ConfigInteger,
    ConfigYesNo, ConfigSelection, ConfigText, getConfigListEntry
)
from enigma import eTimer, ePicLoad, iPlayableService, getDesktop
from Tools.Directories import fileExists
import threading
try:
    import queue
except ImportError:
    import Queue as queue
import os
import time

try:
    from urllib.request import urlopen, Request
    from urllib.parse import quote
except ImportError:
    from urllib2 import urlopen, Request
    from urllib import quote
import json

def my_log(msg):
    try:
        with open("/tmp/watch_debug.log", "a") as f:
            f.write(msg + "\n")
    except: pass


# eEPGCache imported once at module level (not inside a function on every call)
try:
    from enigma import eEPGCache
    _epgcache_available = True
except ImportError:
    _epgcache_available = False
    
try:
    from twisted.internet import reactor
except ImportError:
    pass

# =====================
# KEYS CONFIG (User provides their own TMDB key)
# =====================
_KEYS_CONF_PATH    = "/etc/yourewatching_keys.conf"
_DEFAULT_TMDB_KEY  = "911d7d0ade352ba2bd98c45c96a24cca"  # Developer fallback key

def _load_tmdb_key():
    """Read TMDB_KEY from /etc/yourewatching_keys.conf if it exists."""
    try:
        if os.path.exists(_KEYS_CONF_PATH):
            with open(_KEYS_CONF_PATH, "r") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    if "=" in line:
                        k, v = line.split("=", 1)
                        if k.strip().upper() == "TMDB_KEY" and len(v.strip()) > 10:
                            return v.strip()
    except Exception:
        pass
    return _DEFAULT_TMDB_KEY

# =====================
# CONFIG
# =====================
config.plugins.youreWatching = ConfigSubsection()
config.plugins.youreWatching.enabled  = ConfigYesNo(default=True)
config.plugins.youreWatching.duration = ConfigInteger(default=6, limits=(3, 30))
config.plugins.youreWatching.position = ConfigSelection(
    default="topleft",
    choices=[
        ("topleft",     "Top Left"),
        ("topright",    "Top Right"),
        ("bottomleft",  "Bottom Left"),
        ("bottomright", "Bottom Right"),
    ]
)
config.plugins.youreWatching.interval = ConfigSelection(
    default="0",
    choices=[
        ("0", "Disabled (Show once on zap)"),
        ("2", "Every 2 minutes"),
        ("5", "Every 5 minutes"),
        ("10", "Every 10 minutes"),
        ("15", "Every 15 minutes"),
        ("30", "Every 30 minutes")
    ]
)
config.plugins.youreWatching.size = ConfigSelection(
    default="large",
    choices=[
        ("large", "Large Detailed View"),
        ("compact", "Compact Banner")
    ]
)
config.plugins.youreWatching.style = ConfigSelection(
    default="static",
    choices=[
        ("static", "Static Fixed Window"),
        ("marquee", "Scrolling Marquee Text")
    ]
)
config.plugins.youreWatching.show_upnext = ConfigYesNo(default=True)
config.plugins.youreWatching.tmdb_key = ConfigText(default="", fixed_size=False)

POSTER_PATH  = "/tmp/youre_watching_poster.jpg"
USER_AGENT   = "Mozilla/5.0 (Enigma2 YoureWatchingPlugin/1.0)"

def _get_tmdb_key():
    """Priority: config screen key > keys.conf file > developer default."""
    cfg_key = config.plugins.youreWatching.tmdb_key.value.strip()
    if len(cfg_key) > 10:
        return cfg_key
    return _load_tmdb_key()

# =====================
# KILL SWITCH (Remote Control)
# To disable plugin: update the Pastebin JSON to {"status": "disabled", "message": "..."}
# =====================
_PLUGIN_ACTIVE = True
_PLUGIN_MSG    = ""

def _check_kill_switch():
    global _PLUGIN_ACTIVE, _PLUGIN_MSG
    try:
        try:
            from urllib.request import urlopen, Request as _Req
        except ImportError:
            from urllib2 import urlopen, Request as _Req
        req = _Req(
            "https://raw.githubusercontent.com/asdrere123-alt/YoureWatching/main/status.json",
            headers={"User-Agent": USER_AGENT}
        )
        r = urlopen(req, timeout=4)
        data = json.loads(r.read().decode("utf-8"))
        if data.get("status", "active") != "active":
            _PLUGIN_ACTIVE = False
            _PLUGIN_MSG = data.get("message", "This plugin has been disabled by the developer.")
    except Exception:
        pass  # if server unreachable, keep plugin running

threading.Thread(target=_check_kill_switch, daemon=True).start()

# =====================
# THREAD -> MAIN THREAD BRIDGE
# _poll_timer is created at module import time on the MAIN thread.
# Background threads only call .start() - never construct new timers.
# =====================
_main_thread_queue  = queue.Queue()
_poll_timer         = eTimer()   # constructed on main thread at import time
_poll_timer_started = False


def _poll_queue():
    """Drains all pending UI calls on the main Enigma2 thread."""
    global _poll_timer_started
    _poll_timer_started = False
    while True:
        try:
            func, args, kwargs = _main_thread_queue.get_nowait()
            try:
                func(*args, **kwargs)
            except Exception as e:
                print("[YoureWatching] main-thread callback error:", e)
        except queue.Empty:
            break


_poll_timer.callback.append(_poll_queue)


def callInMainThread(func, *args, **kwargs):
    """
    Schedule func(*args, **kwargs) on the main Enigma2 thread using Twisted API.
    """
    from twisted.internet import reactor
    reactor.callFromThread(func, *args, **kwargs)


# =====================
# HELPER: get actual screen dimensions (supports 720p and 1080p)
# =====================
def _getScreenSize():
    try:
        sz = getDesktop(0).size()
        return sz.width(), sz.height()
    except Exception:
        return 1280, 720   # safe fallback


# =====================
# OVERLAY SCREEN
# =====================
class YoureWatchingScreen(Screen):

    def _getGeometry(self):
        pos      = config.plugins.youreWatching.position.value
        size_cfg = config.plugins.youreWatching.size.value
        sw, sh   = _getScreenSize()
        margin   = 40
        
        if size_cfg == "compact":
            w, h = 480, 110
        else:
            w, h = 600, 240
            
        if pos == "topleft":
            return margin, margin, w, h
        elif pos == "topright":
            return sw - w - margin, margin, w, h
        elif pos == "bottomleft":
            return margin, sh - h - margin, w, h
        else:  # bottomright
            return sw - w - margin, sh - h - margin, w, h

    def __init__(self, session, title="", posterPath=None, year_rating="", plot="", cast_text="", on_close_callback=None):
        # skin MUST be set before Screen.__init__
        x, y, w, h = self._getGeometry()
        size_cfg = config.plugins.youreWatching.size.value

        if size_cfg == "compact":
            self.skin = """
            <screen name="YoureWatchingScreen" position="%d,%d" size="%d,%d" flags="wfNoBorder" zPosition="99" backgroundColor="transparent">
                <widget name="background" position="0,0" size="%d,%d" backgroundColor="#C0000000" zPosition="90"/>
                <widget name="poster" position="10,10" size="60,90" zPosition="95" alphatest="blend"/>
                <widget name="label_watching" position="80,10" size="380,20" font="Regular;14" foregroundColor="#BBBBBB" transparent="1" valign="top" halign="left" zPosition="95" noWrap="1"/>
                <widget name="label_title" position="80,30" size="390,30" font="Regular;22" foregroundColor="#FFFFFF" transparent="1" valign="top" halign="left" zPosition="95" noWrap="1"/>
                <widget name="label_rating" position="80,60" size="380,20" font="Regular;16" foregroundColor="#F5C518" transparent="1" valign="top" halign="left" zPosition="95" noWrap="1"/>
                <widget name="label_plot" position="80,80" size="390,20" font="Regular;16" foregroundColor="#DDDDDD" transparent="1" valign="top" halign="left" zPosition="95" noWrap="1"/>
            </screen>
            """ % (x, y, w, h, w, h)
        else:
            self.skin = """
            <screen name="YoureWatchingScreen" position="%d,%d" size="%d,%d" flags="wfNoBorder" zPosition="99" backgroundColor="transparent">
                <widget name="background" position="0,0" size="%d,%d" backgroundColor="#C0000000" zPosition="90"/>
                <widget name="poster" position="15,15" size="140,210" zPosition="95" alphatest="blend"/>
                <widget name="label_watching" position="170,18" size="400,22" font="Regular;16" foregroundColor="#BBBBBB" transparent="1" valign="top" halign="left" zPosition="95" noWrap="1"/>
                <widget name="label_title" position="170,40" size="415,35" font="Regular;28" foregroundColor="#FFFFFF" transparent="1" valign="top" halign="left" zPosition="95" noWrap="1"/>
                <widget name="label_rating" position="170,80" size="400,24" font="Regular;19" foregroundColor="#F5C518" transparent="1" valign="top" halign="left" zPosition="95" noWrap="1"/>
                <widget name="label_plot" position="170,115" size="410,110" font="Regular;18" foregroundColor="#DDDDDD" transparent="1" valign="top" halign="left" zPosition="95"/>
            </screen>
            """ % (x, y, w, h, w, h)

        Screen.__init__(self, session)

        self["background"]     = Label("")
        self["poster"]         = Pixmap()
        self["label_watching"] = Label("You're watching...")
        self["label_title"]    = Label(title or "")
        self["label_rating"]   = Label(year_rating or "")
        
        self.full_text = ""
        if plot: self.full_text += plot + "  "
        if cast_text: self.full_text += cast_text

        self["label_plot"]     = Label(self.full_text)

        self._title      = title
        self._posterPath = posterPath
        self._plugin_ref = None # Will hold reference to YoureWatchingPlugin
        self._is_up_next = False
        self._closed     = False

        self.picLoad = ePicLoad()
        self.picLoad.PictureData.get().append(self._paintPosterDone)

        self.hideTimer = eTimer()
        self.hideTimer.callback.append(self._doClose)
        
        self.marqueeTimer = eTimer()
        self.marqueeTimer.callback.append(self._onMarqueeTick)
        self.marquee_idx = 0

        self.onLayoutFinish.append(self._onStart)

    def _onMarqueeTick(self):
        if not self.full_text or len(self.full_text) < 50:
            return
        self.marquee_idx += 2
        if self.marquee_idx > len(self.full_text):
            self.marquee_idx = 0
            
        display_text = self.full_text[self.marquee_idx:] + "   ***   " + self.full_text[:self.marquee_idx]
        self["label_plot"].setText(display_text.replace("\n", " "))

    def _onStart(self):
        self._resetTimer()
        if self._posterPath and fileExists(self._posterPath):
            self._loadPoster(self._posterPath)

    def _resetTimer(self):
        try:
            self.hideTimer.stop()
            self.marqueeTimer.stop()
            duration = config.plugins.youreWatching.duration.value * 1000
            self.hideTimer.start(duration, True)
            
            if config.plugins.youreWatching.style.value == "marquee" and self.full_text:
                self.marqueeTimer.start(300, False) # update every 300ms
        except Exception as e:
            print("[YoureWatching] _resetTimer error:", e)

    def _loadPoster(self, path):
        try:
            instance = self["poster"].instance
            # Guard: instance can be None if widget not yet fully initialized
            if instance is None:
                return
            sc = instance.size()
            # [width, height, aspect(1=keep ratio), cache(0=off),
            #  desaturate(0=off), rotate(0=off), bg_color]
            self.picLoad.setPara([sc.width(), sc.height(), 1, 0, 0, 0, "#00000000"])
            self.picLoad.startDecode(path)
        except Exception as e:
            print("[YoureWatching] _loadPoster error:", e)

    def _paintPosterDone(self, picInfo=None):
        try:
            if self._closed:
                return
            ptr = self.picLoad.getData()
            if ptr is not None:
                self["poster"].instance.setPixmap(ptr)
        except Exception as e:
            print("[YoureWatching] _paintPosterDone error:", e)

    def _doClose(self):
        if self._closed:
            return
        self._closed = True
        try:
            self.hideTimer.stop()
            self.marqueeTimer.stop()
            self.picLoad.PictureData.get().remove(self._paintPosterDone)
        except Exception:
            pass
        try:
            self.hide()
        except Exception:
            pass
        try:
            self.close()
        except Exception:
            pass
            
        if self._plugin_ref and getattr(self._plugin_ref, 'currentScreen', None) == self:
            self._plugin_ref.currentScreen = None
            
        # Trigger Up Next exactly when this screen finishes closing
        if self._plugin_ref and config.plugins.youreWatching.show_upnext.value and not self._is_up_next:
            try:
                self._plugin_ref.trigger_up_next_delayed()
            except Exception as e:
                print("[YoureWatching] up next trigger error:", e)

    def updateText(self, title, rating_text, plot_text, cast_text):
        if title:
            self["label_title"].setText(title)
            self._title = title
        if rating_text:
            self["label_rating"].setText(rating_text)
            
        self.full_text = ""
        if plot_text: self.full_text += plot_text + "  "
        if cast_text: self.full_text += cast_text
        
        self.marquee_idx = 0
        self["label_plot"].setText(self.full_text.replace("\n", " "))

    def forceClose(self):
        """Called externally (next zap or plugin shutdown)."""
        try:
            self.hideTimer.stop()
        except Exception:
            pass
        self._doClose()


# =====================
# MAIN PLUGIN CLASS
# =====================
class YoureWatchingPlugin:

    def __init__(self, session):
        my_log('[INIT] YoureWatching Plugin started')
        self.session       = session
        self.currentScreen = None
        self._latestTitle  = None
        self._latestTitle  = None
        self._latestTitle  = None
        self._last_overlay_args = None

        self.interval_task = None
        self.next_event_task = None

        self.session.nav.event.append(self._onNavEvent)

    def _onIntervalTick(self):
        my_log('[TIMER] Interval tick triggered')
        
        # Restart the timer for continuous looping
        try:
            if self.interval_task and self.interval_task.active():
                self.interval_task.cancel()
            interval_mins = int(config.plugins.youreWatching.interval.value)
            if interval_mins > 0:
                self.interval_task = reactor.callLater(interval_mins * 60.0, self._onIntervalTick)
        except Exception as e:
            my_log('[TIMER] Interval restart error: {}'.format(e))
            
        if getattr(self, 'currentScreen', None) is not None:
            return # Don't show if it's currently already on screen
            
        if not _PLUGIN_ACTIVE or not config.plugins.youreWatching.enabled.value:
            return
            
        if self._last_overlay_args:
            my_log('[TIMER] Re-showing last overlay for interval')
            self.currentScreen = None # Force a fresh screen draw
            self._showOverlay(*self._last_overlay_args)
            
    def trigger_up_next_delayed(self):
        """Called by Screen when it closes to spawn the Up Next screen."""
        self.currentScreen = None # Unlink old screen so new one is forced to draw
        try:
            if self.next_event_task and self.next_event_task.active():
                self.next_event_task.cancel()
            self.next_event_task = reactor.callLater(2.0, self._onNextEventAlert)
            my_log('[NEXT] Started 2-second delay for Up Next via reactor')
        except Exception as e:
            print("[YoureWatching] trigger_up_next_delayed error:", e)

    def _onNextEventAlert(self):
        my_log('[TIMER] Next Event Alert triggered')
        if not _PLUGIN_ACTIVE or not config.plugins.youreWatching.enabled.value:
            return
            
        try:
            service = self.session.nav.getCurrentService()
            if not service: return
            info = service.info()
            if not info: return
            
            next_title = ""
            try:
                # getEvent(1) gets the NEXT event
                evt = info.getEvent(1)
                if evt:
                    next_title = evt.getEventName() or ""
            except Exception:
                pass
                
            if not next_title and _epgcache_available:
                try:
                    epgcache = eEPGCache.getInstance()
                    ref = self.session.nav.getCurrentlyPlayingServiceReference()
                    if ref:
                        # lookupEventTime with direction 1 usually gets the next event
                        evt = epgcache.lookupEventTime(ref, int(time.time()), 1)
                        if evt:
                            next_title = evt.getEventName() or ""
                except Exception:
                    pass
                    
            if next_title:
                next_title = self._cleanTitle(next_title.strip())
                if len(next_title) > 1:
                    my_log('[NEXT] Showing UP NEXT alert for: {}'.format(next_title))
                    self._latestTitle = next_title # Prevent duplicate
                    sref = self.session.nav.getCurrentlyPlayingServiceReference()
                    
                    # Force the UI to show IMMEDIATELY to confirm timer isn't failing
                    full_next_title = "Up Next: " + next_title
                    self._showOverlay(full_next_title, None, is_update=False, is_up_next=True)
                    
                    t = threading.Thread(
                        target=self._fetchUpNextPoster,
                        args=(next_title, sref),
                        daemon=True
                    )
                    t.start()
        except Exception as e:
            print("[YoureWatching] _onNextEventAlert error:", e)

    def _onNavEvent(self, event):
        my_log('[EVENT] NavEvent triggered: {}'.format(event))
        if not _PLUGIN_ACTIVE:
            return
        if not config.plugins.youreWatching.enabled.value:
            return
            
        valid_events = [iPlayableService.evStart]
        if hasattr(iPlayableService, 'evUpdatedEventInfo'):
            valid_events.append(iPlayableService.evUpdatedEventInfo)
            
        if event in valid_events:
            self._onServiceChanged()

    def _onServiceChanged(self):
        my_log('[SVC] Service Changed called')
        try:
            if self.interval_task and self.interval_task.active():
                self.interval_task.cancel()
            if self.next_event_task and self.next_event_task.active():
                self.next_event_task.cancel()
            
            # Start interval timer (using reactor callLater)
            try:
                interval_mins = int(config.plugins.youreWatching.interval.value)
                if interval_mins > 0:
                    self.interval_task = reactor.callLater(interval_mins * 60.0, self._onIntervalTick)
            except Exception as e:
                my_log('[SVC] Interval timer error: {}'.format(e))
                
            service = self.session.nav.getCurrentService()
            if not service:
                my_log('[SVC] No service found')
                return
            info = service.info()
            if not info:
                return

            title = ""

            # Priority 1: EPG current event via iServiceInformation.getEvent()
            current_event = None
            try:
                evt = info.getEvent(0)
                if evt:
                    title = evt.getEventName() or ""
                    current_event = evt
            except Exception:
                pass

            # Priority 2: eEPGCache direct lookup
            if not title.strip() and _epgcache_available:
                try:
                    epgcache = eEPGCache.getInstance()
                    ref = self.session.nav.getCurrentlyPlayingServiceReference()
                    if ref:
                        evt = epgcache.lookupEventTime(ref, int(time.time()), 0)
                        if evt:
                            title = evt.getEventName() or ""
                except Exception:
                    pass

            # Priority 3: Channel/service name as absolute last resort
            if not title.strip():
                try:
                    title = info.getName() or ""
                except Exception:
                    pass

            title = self._cleanTitle(title.strip())
            if len(title) < 2:
                return

            # Avoid re-fetching if it's the exact same program (happens on some redundant EPG events)
            if getattr(self, '_latestTitle', None) == title:
                my_log('[SVC] Exact same program detected, skipping redundant fetch.')
                # Even if skipping fetch, if interval is enabled we should make sure the timer is running
                
                # Show the overlay instantly without re-fetching if it's the same program
                if self._last_overlay_args:
                    self._showOverlay(*self._last_overlay_args)
                return

            self._latestTitle = title
            my_log('[FETCH] Cleaned Title to search: {}'.format(title))

            sref = self.session.nav.getCurrentlyPlayingServiceReference()
            
            # INSTANT REACTION: Show the Picon instantly (0ms delay) while TMDB searches in background
            initial_picon = self._getPicon(sref) if sref else None
            # Do an initial fast show
            self._showOverlay(title, initial_picon, is_update=False)

            t = threading.Thread(
                target=self._fetchPoster,
                args=(title, sref),
                daemon=True
            )
            t.start()

        except Exception as e:
            print("[YoureWatching] _onServiceChanged error:", e)

    def _cleanTitle(self, title):
        import re
        # Remove years in parentheses e.g. (2023)
        title = re.sub(r'\(\d{4}\)', '', title)
        # Remove common Arabic/English EPG prefixes and suffixes
        junk_words = [
            r'ÙÙŠÙ„Ù…\s*', r'Ù…Ø³Ø±Ø­ÙŠØ©\s*', r'Ø¨Ø±Ù†Ø§Ù…Ø¬\s*', r'Ù…Ø³Ù„Ø³Ù„\s*',
            r'Ø­Ù„Ù‚Ø©\s*\d+', r'Ù…Ø¨Ø§Ø´Ø±\s*', r'Ø­ØµØ±ÙŠ\s*', r'HD\s*', r'SD\s*', r'4K\s*',
            r'\[.*?\]', r'\(.*?\)', r'Season\s*\d+', r'Episode\s*\d+',
            r'S\d+E\d+', r'Part\s*\d+', r'Ø§Ù„Ø¬Ø²Ø¡\s*[^ ]+'
        ]
        for word in junk_words:
            title = re.sub(word, '', title, flags=re.IGNORECASE)
        # Clean up extra spaces and hyphens
        title = re.sub(r'[\-:]', ' ', title)
        return title.strip()


    def _getPicon(self, service_ref):
        import os
        from enigma import eServiceReference
        
        # Enigma2 standard picon paths
        search_paths = [
            "/media/usb/picon/",
            "/media/hdd/picon/",
            "/usr/share/enigma2/picon/",
            "/media/ba/picon/" # For some multi-boot systems
        ]
        
        # Format the service reference to match typical Enigma2 picon naming (e.g. 1_0_1_X_X_X...)
        try:
            ref_str = service_ref.toString().replace(':', '_')
            if ref_str.endswith('_'):
                ref_str = ref_str[:-1]
            picon_name = ref_str + ".png"
            
            for path in search_paths:
                full_path = os.path.join(path, picon_name)
                if os.path.exists(full_path):
                    return full_path
                    
            # Fallback for some weird references that add extra params
            ref_parts = ref_str.split('_')
            if len(ref_parts) >= 10:
                short_name = '_'.join(ref_parts[:10]) + ".png"
                for path in search_paths:
                    full_path = os.path.join(path, short_name)
                    if os.path.exists(full_path):
                        return full_path
        except Exception as e:
            my_log('[PICON] Error resolving picon: {}'.format(e))
            
        return None

    def _fetchPoster(self, title, sref=None):
        """Runs in background thread."""
        posterPath = None
        original_search_title = title  # Track original to check for channel zaps
        
        # Strip "Up Next: " prefix for the pure TMDB search query
        search_title = title.replace("Up Next: ", "")
        
        try:

            # Search universally (no language restriction) to guarantee the Polish/foreign TMDB title hooks
            url = (
                "https://api.themoviedb.org/3/search/multi"
                "?api_key=%s&query=%s&page=1&include_adult=false"
            ) % (_get_tmdb_key(), quote(search_title, safe=""))

            req      = Request(url, headers={"User-Agent": USER_AGENT})
            response = urlopen(req, timeout=5)
            data     = json.loads(response.read().decode("utf-8"))
            results  = data.get("results", [])

            tmdb_title = search_title  # Default to the pure EPG title if TMDB fails
            
            if results:
                # 1. CRITICAL FIX: Sort by popularity DESCENDING to weed out zero-vote local indie films
                results = sorted(results, key=lambda x: x.get("popularity", 0), reverse=True)
                
                # Find the most popular movie that actually has a backdrop
                item = None
                poster = None
                for r in results:
                    if r.get("backdrop_path"):
                        item = r
                        poster = r.get("backdrop_path")
                        break
                        
                # If no backdrop exists at all, just take the #1 most popular entry
                if not item:
                    item = results[0]
                
                # 2. Extract the true English name from the popular entry
                # BUT ONLY IF THE ORIGINAL TITLE IS NOT ARABIC
                import re
                is_arabic = bool(re.search(r'[Ø€-Û¿]', original_search_title))
                
                extracted_title = (
                    item.get("title") or 
                    item.get("name") or 
                    item.get("original_title") or 
                    item.get("original_name")
                )
                
                if not is_arabic and extracted_title:
                    tmdb_title = extracted_title
                    is_up_next = title.startswith("Up Next:")
                    if is_up_next:
                        title = "Up Next: " + tmdb_title
                    else:
                        title = tmdb_title # Replace EPG translation safely
                    my_log('[TMDB] Translated Title: {}'.format(title))
                elif is_arabic:
                    my_log('[TMDB] Skipped translation (Arabic detected)')
                
                # 3. Extract Rating and Year
                rating_text = ""
                vote = item.get("vote_average")
                date = item.get("release_date") or item.get("first_air_date")
                
                if vote and float(vote) > 0:
                    rating_text += "â˜… {}/10   ".format(round(float(vote), 1))
                if date and len(date) >= 4:
                    rating_text += "ðŸ“… {}".format(date[:4])
                    
                # 4. Extract Plot (Overview)
                plot_text = item.get("overview", "")
                if plot_text:
                    # Truncate to avoid overlapping the UI (approx 200 chars)
                    if len(plot_text) > 230:
                        plot_text = plot_text[:227].rsplit(' ', 1)[0] + "..."
                else:
                    plot_text = ""

                # 4.5. Extract Cast (Top 3 actors) via Credits API
                cast_text = ""
                item_id = item.get("id")
                media_type = item.get("media_type")
                if item_id and media_type in ["movie", "tv"]:
                    try:
                        credits_url = "https://api.themoviedb.org/3/%s/%s/credits?api_key=%s" % (media_type, item_id, _get_tmdb_key())
                        creq = Request(credits_url, headers={"User-Agent": USER_AGENT})
                        cresp = urlopen(creq, timeout=3)
                        cdata = json.loads(cresp.read().decode("utf-8"))
                        cast_list = cdata.get("cast", [])
                        if cast_list:
                            top_cast = [c.get("name") for c in cast_list[:3] if c.get("name")]
                            if top_cast:
                                cast_text = "ðŸŽ­ Cast: " + ", ".join(top_cast)
                    except Exception as e:
                        my_log('[TMDB] Cast fetch error: {}'.format(e))

                # 5. Extract the proper vertical Poster (not the backdrop)
                poster = item.get("poster_path")

                if poster:
                    # Use w342 for sharp vertical posters
                    img_url = "https://image.tmdb.org/t/p/w342" + poster
                    my_log('[TMDB] Found poster: {}'.format(img_url))
                    if os.path.exists(POSTER_PATH):
                        os.remove(POSTER_PATH)
                    img_req      = Request(img_url, headers={"User-Agent": USER_AGENT})
                    img_response = urlopen(img_req, timeout=5)
                    with open(POSTER_PATH, "wb") as f:
                        f.write(img_response.read())
                    if os.path.exists(POSTER_PATH) and os.path.getsize(POSTER_PATH) > 0:
                        posterPath = POSTER_PATH

        except Exception as e:
            print("[YoureWatching] _fetchPoster error:", e)

        # Cache arguments for the interval timer (ONLY for main shows, not Up Next)
        if not title.startswith("Up Next:"):
            # Ensure it's ALWAYS cached so intervals don't die on TMDB failure
            self._last_overlay_args = (title, posterPath, True, rating_text, plot_text, cast_text, False)

        # ALWAYS update the UI so the corrected English (or original) title shows up unconditionally
        is_up_next = title.startswith("Up Next:")
        callInMainThread(self._showOverlay, title, posterPath, True, rating_text, plot_text, cast_text, is_up_next)

    def _fetchUpNextPoster(self, title, sref=None):
        """Dedicated background thread for Up Next."""
        posterPath = None
        rating_text = ""
        plot_text = ""
        cast_text = ""
        
        try:
            url = (
                "https://api.themoviedb.org/3/search/multi"
                "?api_key=%s&query=%s&page=1&include_adult=false"
            ) % (_get_tmdb_key(), quote(title, safe=""))

            req      = Request(url, headers={"User-Agent": USER_AGENT})
            response = urlopen(req, timeout=5)
            data     = json.loads(response.read().decode("utf-8"))
            results  = data.get("results", [])

            tmdb_title = title
            
            if results:
                results = sorted(results, key=lambda x: x.get("popularity", 0), reverse=True)
                item = None
                poster = None
                for r in results:
                    if r.get("backdrop_path"):
                        item = r
                        poster = r.get("backdrop_path")
                        break
                        
                if not item:
                    item = results[0]
                
                import re
                is_arabic = bool(re.search(r'[Ø€-Û¿]', title))
                
                extracted_title = (
                    item.get("title") or 
                    item.get("name") or 
                    item.get("original_title") or 
                    item.get("original_name")
                )
                
                if not is_arabic and extracted_title:
                    tmdb_title = extracted_title
                
                vote = item.get("vote_average")
                date = item.get("release_date") or item.get("first_air_date")
                
                if vote and float(vote) > 0:
                    rating_text += "â˜… {}/10   ".format(round(float(vote), 1))
                if date and len(date) >= 4:
                    rating_text += "ðŸ“… {}".format(date[:4])
                    
                plot_text = item.get("overview", "")
                if plot_text and len(plot_text) > 230:
                    plot_text = plot_text[:227].rsplit(' ', 1)[0] + "..."
                
                cast_text = ""
                item_id = item.get("id")
                media_type = item.get("media_type")
                if item_id and media_type in ["movie", "tv"]:
                    try:
                        credits_url = "https://api.themoviedb.org/3/%s/%s/credits?api_key=%s" % (media_type, item_id, _get_tmdb_key())
                        creq = Request(credits_url, headers={"User-Agent": USER_AGENT})
                        cresp = urlopen(creq, timeout=3)
                        cdata = json.loads(cresp.read().decode("utf-8"))
                        cast_list = cdata.get("cast", [])
                        if cast_list:
                            top_cast = [c.get("name") for c in cast_list[:3] if c.get("name")]
                            if top_cast:
                                cast_text = "ðŸŽ­ Cast: " + ", ".join(top_cast)
                    except Exception as e:
                        pass

                poster = item.get("poster_path")
                if poster:
                    img_url = "https://image.tmdb.org/t/p/w342" + poster
                    UPNEXT_POSTER_PATH = "/tmp/yw_upnext_poster.jpg"
                    if os.path.exists(UPNEXT_POSTER_PATH):
                        os.remove(UPNEXT_POSTER_PATH)
                    img_req      = Request(img_url, headers={"User-Agent": USER_AGENT})
                    img_response = urlopen(img_req, timeout=5)
                    with open(UPNEXT_POSTER_PATH, "wb") as f:
                        f.write(img_response.read())
                    if os.path.exists(UPNEXT_POSTER_PATH) and os.path.getsize(UPNEXT_POSTER_PATH) > 0:
                        posterPath = UPNEXT_POSTER_PATH

        except Exception as e:
            print("[YoureWatching] _fetchUpNextPoster error:", e)

        full_title = "Up Next: " + tmdb_title
        callInMainThread(self._showOverlay, full_title, posterPath, True, rating_text, plot_text, cast_text, True)

    def _showOverlay(self, title, posterPath, is_update=False, rating_text="", plot_text="", cast_text="", is_up_next=False):
        """Must only be called on the main Enigma2 thread."""
        my_log('[SHOW] Overlay showing for {}, poster: {}, update: {}'.format(title, posterPath, is_update))
        try:
            # Force everything to draw a fresh screen (no silent updates to hidden screens)
            if self.currentScreen is not None:
                try:
                    self.currentScreen.forceClose()
                except Exception:
                    pass
                self.currentScreen = None

            # Create new screen
            self.currentScreen = self.session.instantiateDialog(
                YoureWatchingScreen,
                title=title,
                posterPath=posterPath,
                year_rating=rating_text,
                plot=plot_text,
                cast_text=cast_text
            )
            self.currentScreen._plugin_ref = self
            self.currentScreen._is_up_next = is_up_next
            self.currentScreen.show()

        except Exception as e:
            print("[YoureWatching] _showOverlay error:", e)

    def destroy(self):
        """Clean up on plugin shutdown."""
        try:
            self.session.nav.event.remove(self._onNavEvent)
        except Exception:
            pass
        if self.currentScreen is not None:
            try:
                self.currentScreen.forceClose()
            except Exception:
                pass
            self.currentScreen = None
            
        try:
            if self.interval_task and self.interval_task.active():
                self.interval_task.cancel()
            if self.next_event_task and self.next_event_task.active():
                self.next_event_task.cancel()
        except Exception:
            pass


# =====================
# SETUP SCREEN
# =====================
class YoureWatchingSetup(Screen, ConfigListScreen):
    # Note: apostrophe in XML attribute must be &apos;
    skin = """
    <screen name="YoureWatchingSetup"
            position="center,center" size="580,420"
            title="You&apos;re Watching - Settings">
        <widget name="config"
                position="10,10" size="560,350"
                scrollbarMode="showOnDemand"/>
        <widget name="key_green"
                position="10,380" size="260,30"
                font="Regular;18" foregroundColor="#00ff00"
                halign="left" transparent="1"/>
        <widget name="key_red"
                position="310,380" size="260,30"
                font="Regular;18" foregroundColor="#ff0000"
                halign="right" transparent="1"/>
    </screen>
    """

    def __init__(self, session):
        my_log('[INIT] YoureWatching Plugin started')
        Screen.__init__(self, session)
        
        self.list = [
            getConfigListEntry("Enable Plugin:",
                               config.plugins.youreWatching.enabled),
            getConfigListEntry("Display Duration (sec):",
                               config.plugins.youreWatching.duration),
            getConfigListEntry("Position:",
                               config.plugins.youreWatching.position),
            getConfigListEntry("Display Size:",
                               config.plugins.youreWatching.size),
            getConfigListEntry("Display Style:",
                               config.plugins.youreWatching.style),
            getConfigListEntry("Show UP NEXT Info:",
                               config.plugins.youreWatching.show_upnext),
            getConfigListEntry("Notification Interval:",
                               config.plugins.youreWatching.interval),
            getConfigListEntry("TMDB API Key (optional):",
                               config.plugins.youreWatching.tmdb_key),
        ]
        ConfigListScreen.__init__(self, self.list, session=session)

        self["key_green"] = Label("Green: Save")
        self["key_red"]   = Label("Red/Exit: Cancel")
        self["config"] = ConfigList(self.list, session=session)

        # "ok" handled by ConfigList itself to open entry editor
        # green/save = save and close, red/cancel = discard and close
        self["actions"] = ActionMap(
            ["SetupActions", "ColorActions"],
            {
                "green":  self._save,
                "save":   self._save,
                "cancel": self.close,
                "red":    self.close,
            },
            -1
        )

    def _save(self):
        for entry in self.list:
            entry[1].save()
        self.close()


# =====================
# PLUGIN REGISTRATION
# =====================
_plugin_instance = None


def _autoStart(reason, **kwargs):
    global _plugin_instance
    if reason == 0 and "session" in kwargs:
        _plugin_instance = YoureWatchingPlugin(kwargs["session"])
    elif reason == 1:
        if _plugin_instance is not None:
            _plugin_instance.destroy()
        _plugin_instance = None


def _openSetup(session, **kwargs):
    session.open(YoureWatchingSetup)


def Plugins(**kwargs):
    return [
        PluginDescriptor(
            name="You're Watching",
            description="Shows movie title and poster when switching channels",
            where=PluginDescriptor.WHERE_SESSIONSTART,
            fnc=_autoStart,
        ),
        PluginDescriptor(
            name="You're Watching - Settings",
            description="Configure You're Watching plugin",
            where=PluginDescriptor.WHERE_PLUGINMENU,
            fnc=_openSetup,
        ),
    ]
